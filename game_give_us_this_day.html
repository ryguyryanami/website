<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Meditative Prayer Player</title>
<style>
  :root{
    --bg:#071023;
    --panel: rgba(255,255,255,0.04);
    --text: rgba(255,255,255,0.92);
    --muted: rgba(255,255,255,0.6);
  }
  html,body{
    height:100%;
    margin:0;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: radial-gradient(ellipse at 20% 10%, rgba(29,40,73,0.25), transparent 15%),
                radial-gradient(ellipse at 80% 80%, rgba(68,24,80,0.15), transparent 18%),
                var(--bg);
    color:var(--text);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  .container{
    min-height:100%;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:20px;
    padding:30px;
    box-sizing:border-box;
  }

  .stage{
    width:min(980px, 96vw);
    max-width:980px;
    height:56vh;
    min-height:420px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    border-radius:18px;
    box-shadow: 0 8px 40px rgba(0,0,0,0.6);
    overflow:hidden;
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  canvas#viz{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    display:block;
  }

  .controls{
    display:flex;
    gap:12px;
    align-items:center;
    z-index:6;
    position:relative;
  }

  .btn{
    background:var(--panel);
    border:none;
    color:var(--text);
    padding:10px 14px;
    border-radius:10px;
    cursor:pointer;
    font-size:15px;
    backdrop-filter: blur(4px);
  }
  .btn:active{ transform: translateY(1px); }

  .info {
    color:var(--muted);
    font-size:14px;
  }

  .text-overlay{
    position:relative;
    z-index:5;
    pointer-events:none;
    text-align:center;
    width:88%;
    max-width:900px;
  }

  .verse{
    font-size:clamp(18px, 2.3vh, 26px);
    line-height:1.45;
    font-weight:500;
    color:var(--text);
    text-shadow: 0 6px 20px rgba(3,7,20,0.6);
    margin:0 auto;
    opacity:0;
    transition:opacity 0.9s ease, transform 0.9s ease;
    transform: translateY(6px);
    max-width:80%;
    border-radius:10px;
    padding:6px 12px;
    backdrop-filter: blur(2px);
  }

  .verse.visible{
    opacity:1;
    transform: translateY(0px);
  }

  .small{
    font-size:13px;
    color:var(--muted);
  }

  .controls .range{
    width:160px;
  }

  .footer{
    margin-top:6px;
    color:var(--muted);
    font-size:13px;
  }

  /* subtle vignette */
  .stage::after{
    content:"";
    position:absolute;
    inset:0;
    pointer-events:none;
    background: radial-gradient(70% 60% at 50% 45%, rgba(255,255,255,0.02), transparent 25%),
                linear-gradient(180deg, rgba(0,0,0,0.08), transparent 30%);
    mix-blend-mode: overlay;
  }

  @media (max-width:600px){
    .stage { height:62vh; min-height:380px; }
    .controls{ flex-wrap:wrap; justify-content:center;}
  }
</style>
</head>
<body>
<div class="container">
  <div class="stage" role="region" aria-label="Meditative visualizer and prayer text">
    <canvas id="viz"></canvas>

    <div class="text-overlay" aria-live="polite">
      <p id="verse" class="verse">Press Play to begin</p>
      <p id="sub" class="small" style="margin-top:8px; opacity:0.9">Prepare yourself...</p>
    </div>

  </div>

  <div class="controls" aria-hidden="false">
    <button id="playBtn" class="btn" aria-pressed="false">Play</button>
    <button id="pauseBtn" class="btn" disabled>Pause</button>
    <button id="restartBtn" class="btn" disabled>Restart</button>

    <label class="info" style="margin-left:8px;">
      Volume
      <input id="vol" class="range" type="range" min="0" max="1" step="0.01" value="0.85" />
    </label>

    <div style="width:14px"></div>

    <div class="info" id="timeInfo">00:00 / 01:40</div>
  </div>


  <!-- audio element (hidden) -->
  <audio id="audio" src="give_us_this_day.mp3" crossorigin="anonymous"></audio>
</div>

<script>
/*
  Behavior:
  - On Play: resume AudioContext, start audio, start visualization, and start a 100s text timeline
  - Verses are shown sequentially across 100 seconds (1m40s).
*/

const TOTAL_DISPLAY_SECONDS = 100; // 1m40s

// Splitting the Lord's Prayer into sensible verses/segments:
const VERSES = [
  "Our Father who art in heaven, hallowed be Thy name.",
  "Thy kingdom come; Thy will be done on earth as it is in heaven.",
  "Give us this day our daily bread;",
  "and forgive us our trespasses, as we forgive those who trespass against us;",
  "and lead us not into temptation,",
  "but deliver us from evil.",
  "For thine is the kingdom, the power and the glory, forever. Amen."
];

// ---------- DOM ----------
const audioEl = document.getElementById('audio');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const restartBtn = document.getElementById('restartBtn');
const volRange = document.getElementById('vol');
const verseP = document.getElementById('verse');
const timeInfo = document.getElementById('timeInfo');

// visualizer canvas
const canvas = document.getElementById('viz');
const ctx = canvas.getContext('2d', { alpha: true });
let W = canvas.width = canvas.clientWidth;
let H = canvas.height = canvas.clientHeight;

// audio context and analyser
let audioCtx, sourceNode, analyser, dataArray, bufferLength, gainNode;
let rafId;
let startTimestamp = null;
let displayTimerId = null;
let playing = false;

// adapt canvas on resize
function resizeCanvas(){
  W = canvas.width = canvas.clientWidth * devicePixelRatio;
  H = canvas.height = canvas.clientHeight * devicePixelRatio;
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// create simple particle field for meditative motion
const particles = [];
const PARTICLE_COUNT = 48;
function initParticles(){
  particles.length = 0;
  for(let i=0;i<PARTICLE_COUNT;i++){
    particles.push({
      x: Math.random()*W,
      y: Math.random()*H,
      baseX: Math.random()*W,
      baseY: Math.random()*H,
      r: 8 + Math.random()*36,
      phase: Math.random()*Math.PI*2,
      speed: 0.0008 + Math.random()*0.0016,
      blur: 12 + Math.random()*24
    });
  }
}
initParticles();

// prepare audio context and analyser lazily (on first user gesture)
function ensureAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  gainNode = audioCtx.createGain();
  gainNode.gain.value = parseFloat(volRange.value || 0.85);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  bufferLength = analyser.frequencyBinCount;
  dataArray = new Uint8Array(bufferLength);

  // connect audio element
  sourceNode = audioCtx.createMediaElementSource(audioEl);
  sourceNode.connect(gainNode);
  gainNode.connect(analyser);
  analyser.connect(audioCtx.destination);
}

// update volume slider
volRange.addEventListener('input', e=>{
  if(gainNode) gainNode.gain.value = parseFloat(e.target.value);
});

// utilities
function formatTime(s){
  s = Math.max(0, Math.floor(s));
  const mm = String(Math.floor(s/60)).padStart(2,'0');
  const ss = String(s%60).padStart(2,'0');
  return `${mm}:${ss}`;
}

function updateTimeInfo(elapsed){
  const displayed = Math.min(TOTAL_DISPLAY_SECONDS, Math.floor(elapsed));
  timeInfo.textContent = `${formatTime(displayed)} / ${formatTime(TOTAL_DISPLAY_SECONDS)}`;
}

// text timeline: show verses across TOTAL_DISPLAY_SECONDS
function verseIndexForElapsed(elapsed){
  const fraction = Math.max(0, Math.min(1, elapsed / TOTAL_DISPLAY_SECONDS));
  const idx = Math.floor(fraction * VERSES.length);
  return Math.min(VERSES.length - 1, idx);
}

let lastVerseIdx = -1;
function updateDisplayedVerse(elapsed){
  const idx = verseIndexForElapsed(elapsed);
  if(idx !== lastVerseIdx){
    lastVerseIdx = idx;
    // fade out/in smoothly using classes
    verseP.classList.remove('visible');
    // small timeout to allow transition
    setTimeout(()=> {
      verseP.textContent = VERSES[idx];
      verseP.classList.add('visible');
    }, 180);
  }
}

// Visualizer draw
function draw(){
  analyser.getByteFrequencyData(dataArray);

  // clear with slight translucent overlay for trailing blur
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // subtle grainy gradient background
  const g = ctx.createLinearGradient(0,0,W, H);
  g.addColorStop(0, "rgba(10,18,36,0.26)");
  g.addColorStop(1, "rgba(6,8,16,0.18)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // compute a low-frequency energy for central glow
  let lowSum = 0;
  const lowLimit = Math.floor(bufferLength * 0.08);
  for(let i=0;i<lowLimit;i++) lowSum += dataArray[i];
  const lowAvg = lowSum / Math.max(1, lowLimit) / 255; // 0..1

  // central soft glow
  const cx = canvas.clientWidth/2;
  const cy = canvas.clientHeight/2;
  const maxGlow = Math.min(canvas.clientWidth, canvas.clientHeight) * 0.65;
  const glowRadius = 60 + lowAvg * maxGlow;

  const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, glowRadius);
  glow.addColorStop(0, `rgba(180,220,255, ${0.12 + lowAvg*0.15})`);
  glow.addColorStop(0.45, `rgba(120,180,220, ${0.07 + lowAvg*0.08})`);
  glow.addColorStop(1, `rgba(10,12,16, 0.0)`);
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = glow;
  ctx.beginPath();
  ctx.arc(cx, cy, glowRadius, 0, Math.PI*2);
  ctx.fill();

  // draw particles that pulse with sound
  const time = performance.now();
  for(let i=0;i<particles.length;i++){
    const p = particles[i];
    // move with slow orbital motion
    const t = time * p.speed + p.phase;
    p.x = p.baseX + Math.cos(t) * 18 * (0.6 + lowAvg*2);
    p.y = p.baseY + Math.sin(t*0.8) * 18 * (0.6 + lowAvg*2);

    // derive a scale using some frequency bins
    const freqIndex = Math.floor((i/particles.length) * bufferLength * 0.6);
    const energy = dataArray[Math.max(0, Math.min(bufferLength-1, freqIndex))] / 255;
    const r = p.r * (0.6 + energy * 1.4);

    // soft circle with blur via shadow
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.shadowBlur = p.blur;
    ctx.shadowColor = `rgba(160,200,235, ${0.06 + energy*0.45})`;
    ctx.fillStyle = `rgba(120,170,210, ${0.06 + energy*0.32})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // gentle ambient lines (sine waves) across canvas
  ctx.save();
  ctx.globalCompositeOperation = 'screen';
  ctx.lineWidth = 1.2;
  for(let s=0;s<6;s++){
    ctx.beginPath();
    const amp = 12 + s*6 + lowAvg * 40;
    const freq = 0.0025 + s*0.0009;
    const shift = time * (0.0001 + s*0.00002);
    for(let x = 0; x <= canvas.clientWidth; x += 18){
      const y = canvas.clientHeight * (0.45 + s*0.04) + Math.sin((x * freq) + shift) * amp;
      if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.strokeStyle = `rgba(160,200,235, ${0.018 + s*0.008 + lowAvg*0.04})`;
    ctx.stroke();
  }
  ctx.restore();

  // subtle vignette
  ctx.save();
  ctx.globalCompositeOperation = 'multiply';
  const vign = ctx.createRadialGradient(cx, cy, Math.min(W,H)*0.2, cx, cy, Math.max(W,H));
  vign.addColorStop(0, 'rgba(0,0,0,0)');
  vign.addColorStop(1, 'rgba(0,0,0,0.26)');
  ctx.fillStyle = vign;
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.restore();

  // continue loop
  rafId = requestAnimationFrame(draw);
}

// start everything
function startPlayback(){
  if(playing) return;
  ensureAudio();
  // ensure audioContext resumed from user gesture
  if(audioCtx.state === 'suspended'){
    audioCtx.resume().catch(()=>{ /* ignore */ });
  }

  // start audio
  audioEl.currentTime = 0;
  audioEl.play().catch(err=>{
    console.warn('Playback prevented:', err);
  });

  // start timer for verse display
  startTimestamp = performance.now();
  lastVerseIdx = -1;
  updateDisplayedVerse(0);
  updateTimeInfo(0);

  // enable controls
  pauseBtn.disabled = false;
  restartBtn.disabled = false;
  playBtn.setAttribute('aria-pressed','true');

  // start visualizer
  if(!rafId) draw();

  playing = true;

  // set up periodic update loop for text/time
  if(displayTimerId) clearInterval(displayTimerId);
  displayTimerId = setInterval(()=>{
    const elapsed = (performance.now() - startTimestamp)/1000;
    updateTimeInfo(elapsed);
    updateDisplayedVerse(elapsed);
    if(elapsed >= TOTAL_DISPLAY_SECONDS){
      // final verse stays; stop timer but keep audio playing
      updateTimeInfo(TOTAL_DISPLAY_SECONDS);
      clearInterval(displayTimerId);
      displayTimerId = null;
    }
  }, 200);
}

// pause playback
function pausePlayback(){
  if(!playing) return;
  audioEl.pause();
  if(displayTimerId){ clearInterval(displayTimerId); displayTimerId = null; }
  if(rafId){ cancelAnimationFrame(rafId); rafId = null; }
  playBtn.setAttribute('aria-pressed','false');
  pauseBtn.disabled = true;
  restartBtn.disabled = false;
  playing = false;
}

// restart
function restartPlayback(){
  // stop and restart
  if(displayTimerId){ clearInterval(displayTimerId); displayTimerId = null; }
  if(rafId){ cancelAnimationFrame(rafId); rafId = null; }
  audioEl.pause();
  audioEl.currentTime = 0;
  setTimeout(() => {
    startPlayback();
  }, 60);
}

// button wiring
playBtn.addEventListener('click', async ()=>{
  ensureAudio();
  // resume audio context on user gesture
  try{
    await audioCtx.resume();
  }catch(e){}
  startPlayback();
});

pauseBtn.addEventListener('click', ()=>{
  pausePlayback();
});

restartBtn.addEventListener('click', ()=>{
  restartPlayback();
});

// when audio ends, ensure display timer stops at 100s or audio length whichever comes first
audioEl.addEventListener('ended', ()=>{
  // stop viz
  if(rafId){ cancelAnimationFrame(rafId); rafId = null; }
  if(displayTimerId){ clearInterval(displayTimerId); displayTimerId = null; }
  playing
